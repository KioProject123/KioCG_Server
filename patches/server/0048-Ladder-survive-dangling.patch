From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joket_abc <15005771700@qq.com>
Date: Thu, 1 Aug 2024 15:08:55 +0800
Subject: [PATCH] Ladder survive dangling


diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index ff876ec3cf2bcef7be795ba80b3220207d08bb0d..97afb416b85c53b2a56d14c1128d627a19889330 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -644,6 +644,8 @@ public class WorldConfiguration extends ConfigurationPart {
             public String phaseOneMessage = "<red><i>这片区域令你感到不适";
             public String phaseTwoMessage = "<dark_red><i><b>古神在你耳边窃窃私语";
         }
+
+        public boolean ladderSurviveDangling = true;
     }
     // KioCG end
 }
diff --git a/src/main/java/net/minecraft/world/level/block/LadderBlock.java b/src/main/java/net/minecraft/world/level/block/LadderBlock.java
index 4b402a7222f78617ef7d28d329f4daac74954347..71e200f5342e05241605735610362db97b15c83a 100644
--- a/src/main/java/net/minecraft/world/level/block/LadderBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LadderBlock.java
@@ -61,14 +61,57 @@ public class LadderBlock extends Block implements SimpleWaterloggedBlock {
 
     @Override
     protected boolean canSurvive(BlockState state, LevelReader world, BlockPos pos) {
+        // KioCG start
+        return this.canSurviveVanilla(state, world, pos) || this.canSurviveDangling(state, world, pos);
+    }
+    private boolean canSurviveDangling(BlockState state, LevelReader world, BlockPos pos) {
+        if (world instanceof net.minecraft.server.level.ServerLevel level && level.paperConfig().kiocgConfig.ladderSurviveDangling) {
+            final BlockState aboveState = world.getBlockState(pos.above());
+            return aboveState.is(this) && aboveState.getValue(FACING) == state.getValue(FACING);
+        }
+        return false;
+    }
+    private boolean canSurviveVanilla(BlockState state, LevelReader world, BlockPos pos) {
+        // KioCG end
         Direction direction = state.getValue(FACING);
         return this.canAttachTo(world, pos.relative(direction.getOpposite()), direction);
     }
 
+    // KioCG start
+    private void playPlaceSound(net.minecraft.world.level.Level world, BlockState state, net.minecraft.world.entity.player.Player entityhuman, BlockPos pos, @Nullable net.minecraft.world.InteractionHand swing) {
+        boolean defaultReturn = world.checkEntityCollision(state, entityhuman, CollisionContext.of(entityhuman), pos, true); // Paper - Cancel hit for vanished players
+        if (!defaultReturn) {
+            return;
+        }
+
+        if (swing != null) {
+            entityhuman.swing(swing, true);
+        }
+
+        net.minecraft.core.Holder<net.minecraft.sounds.SoundEvent> sound = net.minecraft.core.registries.BuiltInRegistries.SOUND_EVENT.wrapAsHolder(this.soundType.getPlaceSound());
+        double x = pos.getX() + 0.5;
+        double y = pos.getY() + 0.5;
+        double z = pos.getZ() + 0.5;
+        float volume = (this.soundType.getVolume() + 1.0F) / 2.0F;
+        float pitch = this.soundType.getPitch() * 0.8F;
+        ((net.minecraft.server.level.ServerPlayer) entityhuman).connection.send(new net.minecraft.network.protocol.game.ClientboundSoundPacket(sound, net.minecraft.sounds.SoundSource.BLOCKS, x, y, z, volume, pitch, entityhuman.random.nextLong()));
+    }
+
+    @Override
+    protected void tick(BlockState state, net.minecraft.server.level.ServerLevel world, BlockPos pos, net.minecraft.util.RandomSource random) {
+        if (!state.canSurvive(world, pos)) {
+            world.destroyBlock(pos, true);
+        }
+    }
+    // KioCG end
+
     @Override
     protected BlockState updateShape(BlockState state, Direction direction, BlockState neighborState, LevelAccessor world, BlockPos pos, BlockPos neighborPos) {
-        if (direction.getOpposite() == state.getValue(FACING) && !state.canSurvive(world, pos)) {
-            return Blocks.AIR.defaultBlockState();
+        // KioCG start
+        if ((direction.getOpposite() == Direction.DOWN || direction.getOpposite() == state.getValue(FACING)) && !state.canSurvive(world, pos)) {
+            world.scheduleTick(pos, (Block) this, 1);
+            return super.updateShape(state, direction, neighborState, world, pos, neighborPos);
+        // KioCG end
         } else {
             if (state.getValue(WATERLOGGED)) {
                 world.scheduleTick(pos, Fluids.WATER, Fluids.WATER.getTickDelay(world));
@@ -96,7 +139,11 @@ public class LadderBlock extends Block implements SimpleWaterloggedBlock {
         for (Direction direction : ctx.getNearestLookingDirections()) {
             if (direction.getAxis().isHorizontal()) {
                 blockState2 = blockState2.setValue(FACING, direction.getOpposite());
-                if (blockState2.canSurvive(levelReader, blockPos)) {
+                // KioCG start
+                boolean surviveDangling = this.canSurviveDangling(blockState2, levelReader, blockPos);
+                if (this.canSurviveVanilla(blockState2, levelReader, blockPos) || surviveDangling) {
+                    if (surviveDangling && ctx.getPlayer() != null) this.playPlaceSound((net.minecraft.world.level.Level) levelReader, blockState2, ctx.getPlayer(), blockPos, ctx.getHand());
+                // KioCG end
                     return blockState2.setValue(WATERLOGGED, Boolean.valueOf(fluidState.getType() == Fluids.WATER));
                 }
             }
