From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joket_abc <15005771700@qq.com>
Date: Tue, 5 Mar 2024 10:34:43 +0800
Subject: [PATCH] The Long Dark


diff --git a/src/main/java/com/kiocg/java/NamespacedKeys.java b/src/main/java/com/kiocg/java/NamespacedKeys.java
index e3a9806f9972007b732032fd137741a5d14a7e63..f2044f27ec933da4620f0623421659bca2daef16 100644
--- a/src/main/java/com/kiocg/java/NamespacedKeys.java
+++ b/src/main/java/com/kiocg/java/NamespacedKeys.java
@@ -5,4 +5,7 @@ import org.bukkit.NamespacedKey;
 public class NamespacedKeys {
     public static final String KIOCG = "kiocg";
 
+    public static final NamespacedKey kiocgColdValue = new NamespacedKey(KIOCG, "cold_value");
+    public static final NamespacedKey kiocgThirstValue = new NamespacedKey(KIOCG, "thirst_value");
+    public static final NamespacedKey kiocgThirstRegain = new NamespacedKey(KIOCG, "thirst_regain");
 }
diff --git a/src/main/java/com/kiocg/java/player/ColdData.java b/src/main/java/com/kiocg/java/player/ColdData.java
new file mode 100644
index 0000000000000000000000000000000000000000..55ce9bc1c93bdaf2bc88d5c9cc7544ddd3f99d0f
--- /dev/null
+++ b/src/main/java/com/kiocg/java/player/ColdData.java
@@ -0,0 +1,106 @@
+package com.kiocg.java.player;
+
+import com.kiocg.java.NamespacedKeys;
+import io.papermc.paper.configuration.WorldConfiguration;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LightLayer;
+import org.bukkit.persistence.PersistentDataType;
+
+public class ColdData {
+    public static final int MAX_VALUE = 60 * 20 * 10;
+
+    private Player entityhuman;
+    private int tempColdValue;
+    private int coldValueCache;
+
+    public ColdData(Player entityhuman) {
+        org.apache.commons.lang.Validate.notNull(entityhuman);
+        this.entityhuman = entityhuman;
+    }
+
+    public int getColdValue() {
+        return coldValueCache;
+    }
+
+    private int getColdValue0() {
+        return entityhuman.getBukkitEntity().getPersistentDataContainer().getOrDefault(NamespacedKeys.kiocgColdValue, PersistentDataType.INTEGER, MAX_VALUE);
+    }
+
+    public void setColdValue(int value) {
+        entityhuman.getBukkitEntity().getPersistentDataContainer().set(NamespacedKeys.kiocgColdValue, PersistentDataType.INTEGER, value);
+    }
+
+    public void addColdValue(int add) {
+        tempColdValue += add;
+    }
+
+    public float getColdProgress() {
+        return (float) coldValueCache / MAX_VALUE;
+    }
+
+    public boolean isFrozen() {
+        return coldValueCache <= 0;
+    }
+
+    public void tick() {
+        if (!entityhuman.getAbilities().invulnerable) {
+            final Level world = entityhuman.level();
+            final BlockPos pos = entityhuman.blockPosition();
+            final WorldConfiguration.KiocgConfig.TheLongDark theLongDark = world.paperConfig().kiocgConfig.theLongDark;
+
+            final float temperature = (world.getBiome(pos).value().getTemperature(pos) + theLongDark.coldValue.ambientTemperatureOffset) * theLongDark.coldValue.ambientTemperatureOffsetMultiplier;
+            tempColdValue += theLongDark.coldValue.ambientBase + temperature;
+
+            if (theLongDark.coldValue.lightSimulationMultiplier != 0) {
+                int light = world.getRawBrightness(pos, world.getSkyDarken());
+                tempColdValue += light * theLongDark.coldValue.lightSimulationMultiplier;
+            }
+            if (theLongDark.coldValue.lightBlockMultiplier != 0) {
+                int blockLight = world.getBrightness(LightLayer.BLOCK, pos);
+                tempColdValue += blockLight * theLongDark.coldValue.lightBlockMultiplier;
+            }
+            if (theLongDark.coldValue.lightSkyMultiplier != 0) {
+                int skyLight = world.getBrightness(LightLayer.SKY, pos);
+                tempColdValue += skyLight * theLongDark.coldValue.lightSkyMultiplier;
+            }
+
+            if (theLongDark.coldValue.isInWaterOrBubble != 0 && (entityhuman.isInPowderSnow || entityhuman.isInWaterOrBubble())) {
+                tempColdValue += theLongDark.coldValue.isInWaterOrBubble;
+            } else if (theLongDark.coldValue.isInRain != 0 && entityhuman.isInRain()) {
+                tempColdValue += theLongDark.coldValue.isInRain;
+            }
+
+            if (theLongDark.coldValue.isInLava != 0 && entityhuman.isInLava()) {
+                tempColdValue += theLongDark.coldValue.isInLava;
+            } else if (theLongDark.coldValue.onFireTickDivision != 0) {
+                int remainingFireTicks = entityhuman.getRemainingFireTicks();
+                if (remainingFireTicks > 0) {
+                    tempColdValue += remainingFireTicks / theLongDark.coldValue.onFireTickDivision;
+                }
+            }
+
+            int prevValue = coldValueCache;
+            coldValueCache = Mth.clamp(getColdValue0() + tempColdValue, 0, MAX_VALUE);
+            if (prevValue != coldValueCache) {
+                setColdValue(coldValueCache);
+            }
+            tempColdValue = 0;
+
+            ((ServerPlayer) entityhuman).connection.send(new ClientboundSetExperiencePacket(getColdProgress(), entityhuman.totalExperience, entityhuman.experienceLevel));
+        } else {
+            coldValueCache = MAX_VALUE;
+            tempColdValue = 0;
+        }
+    }
+
+    public void reset() {
+        setColdValue(MAX_VALUE);
+        coldValueCache = MAX_VALUE;
+        tempColdValue = 0;
+    }
+}
diff --git a/src/main/java/com/kiocg/java/player/ThirstData.java b/src/main/java/com/kiocg/java/player/ThirstData.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b03e97dd5254f11764b3776f86753c490f20506
--- /dev/null
+++ b/src/main/java/com/kiocg/java/player/ThirstData.java
@@ -0,0 +1,97 @@
+package com.kiocg.java.player;
+
+import com.kiocg.java.NamespacedKeys;
+import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
+import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import org.bukkit.persistence.PersistentDataType;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ThirstData {
+    public static final int MAX_VALUE = 10;
+
+    private Player entityhuman;
+    private int thirstValueCache;
+
+    public ThirstData(Player entityhuman) {
+        org.apache.commons.lang.Validate.notNull(entityhuman);
+        this.entityhuman = entityhuman;
+    }
+
+    public int getThirstValue() {
+        return thirstValueCache;
+    }
+
+    private int getThirstValue0() {
+        return entityhuman.getBukkitEntity().getPersistentDataContainer().getOrDefault(NamespacedKeys.kiocgThirstValue, PersistentDataType.INTEGER, MAX_VALUE);
+    }
+
+    public void setThirstValue(int value) {
+        entityhuman.getBukkitEntity().getPersistentDataContainer().set(NamespacedKeys.kiocgThirstValue, PersistentDataType.INTEGER, value);
+    }
+
+    public int getThirstProgress() {
+        return 300 / 10 * (thirstValueCache - 1) + 8;
+    }
+
+    public boolean isThirsty() {
+        return thirstValueCache <= 0;
+    }
+
+    public void tick() {
+        if (!entityhuman.getAbilities().invulnerable) {
+            double regain = getThirstRegain0();
+            int quotient = (int) regain / 20;
+            if (quotient > 0) {
+                setThirstRegain(regain - 20 * quotient);
+            }
+
+            int prevValue = thirstValueCache;
+            thirstValueCache = Mth.clamp(getThirstValue0() - quotient, 0, MAX_VALUE);
+            if (prevValue != thirstValueCache) {
+                setThirstValue(thirstValueCache);
+            }
+
+            if (thirstValueCache <= 3 && entityhuman.tickCount % 10 == 0) {
+                if (!entityhuman.hasEffect(MobEffects.WEAKNESS) || entityhuman.getEffect(MobEffects.WEAKNESS).getAmplifier() == 0 && entityhuman.getEffect(MobEffects.WEAKNESS).endsWithin(20 - 1)) {
+                    entityhuman.addEffect(new MobEffectInstance(MobEffects.WEAKNESS, 20, 0));
+                }
+            }
+
+            List<SynchedEntityData.DataValue<?>> list = new ArrayList<>();
+            list.add(SynchedEntityData.DataValue.create(Entity.DATA_AIR_SUPPLY_ID, getThirstProgress()));
+            ((ServerPlayer) entityhuman).connection.send(new ClientboundSetEntityDataPacket(entityhuman.getId(), list));
+        } else {
+            thirstValueCache = MAX_VALUE;
+        }
+    }
+
+    public double getThirstRegain() {
+        return getThirstRegain0();
+    }
+
+    private double getThirstRegain0() {
+        return entityhuman.getBukkitEntity().getPersistentDataContainer().getOrDefault(NamespacedKeys.kiocgThirstRegain, PersistentDataType.DOUBLE, 0.0);
+    }
+
+    public void setThirstRegain(double value) {
+        entityhuman.getBukkitEntity().getPersistentDataContainer().set(NamespacedKeys.kiocgThirstRegain, PersistentDataType.DOUBLE, value);
+    }
+
+    public void addThirstRegain(double add) {
+        setThirstRegain(getThirstRegain0() + add);
+    }
+
+    public void reset() {
+        setThirstValue(MAX_VALUE);
+        thirstValueCache = MAX_VALUE;
+        setThirstRegain(0.0);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index 8dfa5027987c74eff98f1b27e343bbab392727fa..4f227e699abcd6dcea8590d9046751a9218bc09a 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -556,6 +556,30 @@ public class WorldConfiguration extends ConfigurationPart {
 
     public class KiocgConfig extends ConfigurationPart {
         public boolean deathItemsOnlyPickedUpByOneself = false;
+
+        public TheLongDark theLongDark;
+        public class TheLongDark extends ConfigurationPart {
+            public double frozenTickDamageMultiplier = 0.01;
+
+            public ColdValue coldValue;
+            public class ColdValue extends ConfigurationPart {
+                public int ambientBase = -10;
+                public float ambientTemperatureOffset = -1.0F;
+                public int ambientTemperatureOffsetMultiplier = 10;
+
+                public int lightSimulationMultiplier = 1;
+                public int lightBlockMultiplier = 2;
+                public int lightSkyMultiplier = 0;
+
+                public int isInWaterOrBubble = -30;
+                public int isInRain = -15;
+                public int isInLava = 50;
+                public int onFireTickDivision = 5;
+            }
+
+            public int campfireExtinguishingOne = -1;
+            public int campfireExtinguishingTwo = -1;
+        }
     }
     // KioCG end
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index bb31b5f33709334fe29f0536c5e4beab1b098aaf..535aacc10546721bdcdc20a33c1861ba37d6aa6f 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -825,7 +825,7 @@ public class ServerPlayer extends Player {
                 this.updateScoreForCriteria(ObjectiveCriteria.LEVEL, Mth.ceil((float) this.lastRecordedLevel));
             }
 
-            if (this.totalExperience != this.lastSentExp) {
+            if (false && this.totalExperience != this.lastSentExp) { // KioCG - cold system
                 this.lastSentExp = this.totalExperience;
                 this.connection.send(new ClientboundSetExperiencePacket(this.experienceProgress, this.totalExperience, this.experienceLevel));
             }
@@ -2747,6 +2747,8 @@ public class ServerPlayer extends Player {
         this.setRemainingFireTicks(0);
         this.fallDistance = 0;
         this.foodData = new FoodData(this);
+        this.coldData = new com.kiocg.java.player.ColdData(this); // KioCG
+        this.thirstData = new com.kiocg.java.player.ThirstData(this); // KioCG
         this.experienceLevel = this.newLevel;
         this.totalExperience = this.newTotalExp;
         this.experienceProgress = 0;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 51902e741f27e9e09d940cf465293a455ad2566a..54eca569be908ca7428706c792fe4e69b56292b3 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -951,7 +951,7 @@ public abstract class PlayerList {
         entityplayer1.connection.teleport(CraftLocation.toBukkit(entityplayer1.position(), worldserver2.getWorld(), entityplayer1.getYRot(), entityplayer1.getXRot())); // CraftBukkit
         entityplayer1.connection.send(new ClientboundSetDefaultSpawnPositionPacket(worldserver1.getSharedSpawnPos(), worldserver1.getSharedSpawnAngle()));
         entityplayer1.connection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
-        entityplayer1.connection.send(new ClientboundSetExperiencePacket(entityplayer1.experienceProgress, entityplayer1.totalExperience, entityplayer1.experienceLevel));
+        entityplayer1.connection.send(new ClientboundSetExperiencePacket(entityplayer1.coldData.getColdProgress(), entityplayer1.totalExperience, entityplayer1.experienceLevel)); // KioCG - cold system
         this.sendLevelInfo(entityplayer1, worldserver1);
         this.sendPlayerPermissionLevel(entityplayer1);
         if (!entityplayer.connection.isDisconnected()) {
@@ -995,6 +995,8 @@ public abstract class PlayerList {
         // Paper start - Add PlayerPostRespawnEvent
         if (isRespawn) {
             cserver.getPluginManager().callEvent(new com.destroystokyo.paper.event.player.PlayerPostRespawnEvent(entityplayer.getBukkitEntity(), location, isBedSpawn));
+            entityplayer.coldData.reset(); // KioCG
+            entityplayer.thirstData.reset(); // KioCG
         }
         // Paper end - Add PlayerPostRespawnEvent
 
diff --git a/src/main/java/net/minecraft/world/effect/SaturationMobEffect.java b/src/main/java/net/minecraft/world/effect/SaturationMobEffect.java
index b994ae09621934df2cdd6a83a7d8ecb44649fb16..e082df98a69246dd015928e2404fa0faab3ae845 100644
--- a/src/main/java/net/minecraft/world/effect/SaturationMobEffect.java
+++ b/src/main/java/net/minecraft/world/effect/SaturationMobEffect.java
@@ -19,6 +19,8 @@ class SaturationMobEffect extends InstantenousMobEffect {
         if (!entity.level().isClientSide && entity instanceof Player) {
             Player entityhuman = (Player) entity;
 
+            if (true) { entityhuman.coldData.addColdValue(amplifier + 1); return; } // KioCG
+
             // CraftBukkit start
             int oldFoodLevel = entityhuman.getFoodData().foodLevel;
             org.bukkit.event.entity.FoodLevelChangeEvent event = CraftEventFactory.callFoodLevelChangeEvent(entityhuman, amplifier + 1 + oldFoodLevel);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index f5a86c0fb1a7a313afc4c56ffc445a7fe7821428..6778bff8924a24f1777cca1efee3c919190675f5 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -357,7 +357,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     private static final int FLAG_INVISIBLE = 5;
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
-    private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT); // KioCG - private -> public
     private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
     private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
@@ -3386,6 +3386,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     }
 
     public int getAirSupply() {
+        if (this instanceof ServerPlayer player) return player.getBukkitEntity().realAir; // KioCG
         return (Integer) this.entityData.get(Entity.DATA_AIR_SUPPLY_ID);
     }
 
@@ -3396,10 +3397,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         if (this.valid) {
             event.getEntity().getServer().getPluginManager().callEvent(event);
         }
-        if (event.isCancelled() && this.getAirSupply() != air) {
+        if (event.isCancelled() && this.getAirSupply() != air && !(this instanceof ServerPlayer)) { // KioCG
             this.entityData.markDirty(Entity.DATA_AIR_SUPPLY_ID);
             return;
         }
+        if (this instanceof ServerPlayer player) { player.getBukkitEntity().realAir = event.getAmount(); } else // KioCG
         this.entityData.set(Entity.DATA_AIR_SUPPLY_ID, event.getAmount());
         // CraftBukkit end
     }
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 23570a0b1227a840b9c1e6ae326827ea655bb5f7..9226de952f4020daa21f659ea710509fc89d093c 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -1366,6 +1366,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
         // Paper end
         float f1 = this.getHealth();
 
+        if (!(this instanceof net.minecraft.world.entity.player.Player player) || !player.thirstData.isThirsty()) { // KioCG
         if (f1 > 0.0F) {
             EntityRegainHealthEvent event = new EntityRegainHealthEvent(this.getBukkitEntity(), f, regainReason, isFastRegen); // Paper
             // Suppress during worldgen
@@ -1375,10 +1376,11 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
             if (!event.isCancelled()) {
                 this.setHealth((float) (this.getHealth() + event.getAmount()));
+                if (this instanceof net.minecraft.world.entity.player.Player player) player.thirstData.addThirstRegain(Math.max(this.getHealth() - f1, 0)); // KioCG
             }
             // CraftBukkit end
         }
-
+        } // KioCG
     }
 
     public float getHealth() {
@@ -3479,17 +3481,23 @@ public abstract class LivingEntity extends Entity implements Attackable {
         if (!this.level().isClientSide && !this.isDeadOrDying() && !this.freezeLocked) { // Paper - Freeze Tick Lock API
             int i = this.getTicksFrozen();
 
-            if (this.isInPowderSnow && this.canFreeze()) {
-                this.setTicksFrozen(Math.min(this.getTicksRequiredToFreeze(), i + 1));
+            if (this.isInPowderSnow && this.canFreeze() || this instanceof net.minecraft.world.entity.player.Player player && player.coldData.isFrozen()) { // KioCG
+                this.setTicksFrozen(i + 1); // KioCG - 不要限制最大值
             } else {
-                this.setTicksFrozen(Math.max(0, i - 2));
+                this.setTicksFrozen(Math.min(this.getTicksRequiredToFreeze(), Math.max(0, i - 2))); // KioCG - 还原最大值设定, 防止长时间冻结
             }
         }
 
         this.removeFrost();
         this.tryAddFrost();
         if (!this.level().isClientSide && this.tickCount % 40 == 0 && this.isFullyFrozen() && this.canFreeze()) {
-            this.hurt(this.damageSources().freeze(), 1.0F);
+            // KioCG start
+            float increase = 0.0F;
+            if (this instanceof net.minecraft.world.entity.player.Player player && player.coldData.isFrozen()) {
+                increase = (this.getTicksFrozen() - this.getTicksRequiredToFreeze()) * (float) this.level().paperConfig().kiocgConfig.theLongDark.frozenTickDamageMultiplier;
+            }
+            this.hurt(this.damageSources().freeze(), 1.0F + increase);
+            // KioCG end
         }
 
         this.level().getProfiler().pop();
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 567704f61034363e48ef2a5b5566ebdc91682297..ca01581d8decc696db11f15bd782308848d97478 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -154,6 +154,8 @@ public abstract class Player extends LivingEntity {
     public final InventoryMenu inventoryMenu;
     public AbstractContainerMenu containerMenu;
     protected FoodData foodData = new FoodData(this); // CraftBukkit - add "this" to constructor
+    public com.kiocg.java.player.ColdData coldData = new com.kiocg.java.player.ColdData(this); // KioCG
+    public com.kiocg.java.player.ThirstData thirstData = new com.kiocg.java.player.ThirstData(this); // KioCG
     protected int jumpTriggerTime;
     public float oBob;
     public float bob;
@@ -280,6 +282,8 @@ public abstract class Player extends LivingEntity {
         this.moveCloak();
         if (!this.level().isClientSide) {
             this.foodData.tick(this);
+            this.coldData.tick(); // KioCG
+            this.thirstData.tick(); // KioCG
             this.awardStat(Stats.PLAY_TIME);
             this.awardStat(Stats.TOTAL_WORLD_TIME);
             if (this.isAlive()) {
diff --git a/src/main/java/net/minecraft/world/food/FoodData.java b/src/main/java/net/minecraft/world/food/FoodData.java
index c3448707fd8a632b457cc97b35d08a9c6933d5ee..3990fad7ee4d218e182fa322613ec991468de69b 100644
--- a/src/main/java/net/minecraft/world/food/FoodData.java
+++ b/src/main/java/net/minecraft/world/food/FoodData.java
@@ -69,6 +69,7 @@ public class FoodData {
 
                 if (!event.isCancelled()) {
                     this.foodLevel = event.getFoodLevel();
+                    player.thirstData.addThirstRegain(Math.max(this.lastFoodLevel - this.foodLevel, 0)); // KioCG
                 }
 
                 ((ServerPlayer) player).connection.send(new ClientboundSetHealthPacket(((ServerPlayer) player).getBukkitEntity().getScaledHealth(), this.foodLevel, this.saturationLevel));
diff --git a/src/main/java/net/minecraft/world/level/block/LavaCauldronBlock.java b/src/main/java/net/minecraft/world/level/block/LavaCauldronBlock.java
index 29d4553df54236706c76fdec0bb14b5d9fb82ff2..3c66b5321749c4095a26052acb32924e822510e6 100644
--- a/src/main/java/net/minecraft/world/level/block/LavaCauldronBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LavaCauldronBlock.java
@@ -35,6 +35,7 @@ public class LavaCauldronBlock extends AbstractCauldronBlock {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(world, pos)).callEvent()) { return; } // Paper - Add EntityInsideBlockEvent
         if (this.isEntityInsideContent(state, pos, entity)) {
             entity.lavaHurt();
+            if (entity instanceof net.minecraft.world.entity.player.Player player) player.coldData.addColdValue(world.paperConfig().kiocgConfig.theLongDark.coldValue.isInLava); // KioCG
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/block/LayeredCauldronBlock.java b/src/main/java/net/minecraft/world/level/block/LayeredCauldronBlock.java
index a4857675772d4fe849ba85fc21a369decca42fc0..19881058e5c0920865161a69280374bc79784151 100644
--- a/src/main/java/net/minecraft/world/level/block/LayeredCauldronBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LayeredCauldronBlock.java
@@ -77,6 +77,7 @@ public class LayeredCauldronBlock extends AbstractCauldronBlock {
             // CraftBukkit end
         }
 
+        if (entity instanceof net.minecraft.world.entity.player.Player player && this.isEntityInsideContent(state, pos, entity)) player.coldData.addColdValue(world.paperConfig().kiocgConfig.theLongDark.coldValue.isInWaterOrBubble); // KioCG
     }
 
     @io.papermc.paper.annotation.DoNotUse @Deprecated // Paper - fix powdered snow cauldron extinguishing entities; use #handleEntityOnFireInsideWithEvent
diff --git a/src/main/java/net/minecraft/world/level/block/entity/CampfireBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/CampfireBlockEntity.java
index 0e8a22684932cc1e181508ea68c48147339e03d4..8f6ffb5f08f3e6d9dbdc50914a85cb89b231f9b9 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/CampfireBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/CampfireBlockEntity.java
@@ -43,6 +43,7 @@ public class CampfireBlockEntity extends BlockEntity implements Clearable {
     public final int[] cookingTime;
     private final RecipeManager.CachedCheck<Container, CampfireCookingRecipe> quickCheck;
     public final boolean[] stopCooking; // Paper - Add more Campfire API
+    private int litTicks = 0; // KioCG
 
     public CampfireBlockEntity(BlockPos pos, BlockState state) {
         super(BlockEntityType.CAMPFIRE, pos, state);
@@ -56,6 +57,28 @@ public class CampfireBlockEntity extends BlockEntity implements Clearable {
     public static void cookTick(Level world, BlockPos pos, BlockState state, CampfireBlockEntity campfire) {
         boolean flag = false;
 
+        // KioCG start
+        ++campfire.litTicks;
+        int extinguishingTick = state.is(net.minecraft.world.level.block.Blocks.CAMPFIRE) ? world.paperConfig().kiocgConfig.theLongDark.campfireExtinguishingOne : world.paperConfig().kiocgConfig.theLongDark.campfireExtinguishingTwo;
+        if (extinguishingTick >= 0 && campfire.litTicks > extinguishingTick) {
+            if (state.is(net.minecraft.world.level.block.Blocks.CAMPFIRE)) {
+                world.removeBlockEntity(pos); // 移除BlockEntity来保留物品
+                world.setBlock(pos, net.minecraft.world.level.block.Blocks.SOUL_CAMPFIRE.withPropertiesOf(state), 3);
+
+                CampfireBlockEntity soulCampfire = (CampfireBlockEntity) world.getBlockEntity(pos);
+                for (int i = 0; i < campfire.items.size(); i++) {
+                    soulCampfire.items.set(i, campfire.items.get(i));
+                }
+                System.arraycopy(campfire.cookingProgress, 0, soulCampfire.cookingProgress, 0, campfire.cookingProgress.length);
+                System.arraycopy(campfire.cookingTime, 0, soulCampfire.cookingTime, 0, campfire.cookingTime.length);
+                System.arraycopy(campfire.stopCooking, 0, soulCampfire.stopCooking, 0, campfire.stopCooking.length);
+            } else {
+                world.setBlock(pos, net.minecraft.world.level.block.Blocks.AIR.defaultBlockState(), 3);
+            }
+            return;
+        }
+        // KioCG end
+
         for (int i = 0; i < campfire.items.size(); ++i) {
             ItemStack itemstack = (ItemStack) campfire.items.get(i);
 
@@ -229,6 +252,8 @@ public class CampfireBlockEntity extends BlockEntity implements Clearable {
             System.arraycopy(cookingState, 0, this.stopCooking, 0, Math.min(this.stopCooking.length, abyte.length));
         }
         // Paper end - Add more Campfire API
+
+        if (nbt.contains("KioCG.LitTicks", org.bukkit.craftbukkit.util.CraftMagicNumbers.NBT.TAG_INT)) litTicks = nbt.getInt("KioCG.LitTicks"); // KioCG
     }
 
     @Override
@@ -244,6 +269,7 @@ public class CampfireBlockEntity extends BlockEntity implements Clearable {
         }
         nbt.putByteArray("Paper.StopCooking", cookingState);
         // Paper end - Add more Campfire API
+        nbt.putInt("KioCG.LitTicks", litTicks); // KioCG
     }
 
     @Override
@@ -299,6 +325,7 @@ public class CampfireBlockEntity extends BlockEntity implements Clearable {
         if (this.level != null) {
             this.markUpdated();
             this.cooldownImmediately(this.getLevel(), this.getBlockPos(), this.getBlockState(), (CampfireBlockEntity) this); // KioCG - 优化未燃烧的运算
+            this.litTicks = 0; // KioCG
         }
 
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 616d2e479d91673695ade0db151a0099b568904f..5d347f6c9dfa389278727560df64bde333355497 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -194,6 +194,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private double health = 20;
     private boolean scaledHealth = false;
     private double healthScale = 20;
+    public int realAir; // KioCG
     private CraftWorldBorder clientWorldBorder = null;
     private BorderChangeListener clientWorldBorderListener = this.createWorldBorderListener();
     public org.bukkit.event.player.PlayerResourcePackStatusEvent.Status resourcePackStatus; // Paper - more resource pack API
@@ -2123,7 +2124,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         playerList.sendAllPlayerInfo(handle);
 
         // Resend their XP and effects because the respawn packet resets it
-        connection.send(new net.minecraft.network.protocol.game.ClientboundSetExperiencePacket(handle.experienceProgress, handle.totalExperience, handle.experienceLevel));
+        connection.send(new net.minecraft.network.protocol.game.ClientboundSetExperiencePacket(handle.coldData.getColdProgress(), handle.totalExperience, handle.experienceLevel)); // KioCG - cold system
         for (net.minecraft.world.effect.MobEffectInstance mobEffect : handle.getActiveEffects()) {
             connection.send(new net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket(handle.getId(), mobEffect));
         }
