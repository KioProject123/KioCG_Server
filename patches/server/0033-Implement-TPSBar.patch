From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joket_abc <15005771700@qq.com>
Date: Tue, 4 Jun 2024 13:28:44 +0800
Subject: [PATCH] Implement TPSBar


diff --git a/src/main/java/com/kiocg/command/TPSBarCommand.java b/src/main/java/com/kiocg/command/TPSBarCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff3fa06944b0c616a5a8ba9e5839f5cbc6085d7e
--- /dev/null
+++ b/src/main/java/com/kiocg/command/TPSBarCommand.java
@@ -0,0 +1,32 @@
+package com.kiocg.command;
+
+import com.kiocg.task.TPSBarTask;
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class TPSBarCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("tpsbar")
+                                    .requires(listener -> listener.hasPermission(2, "bukkit.command.tpsbar"))
+                                    .executes(context -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                                    .then(Commands.argument("targets", EntityArgument.players())
+                                                  .requires(listener -> listener.hasPermission(2, "bukkit.command.tpsbar.other"))
+                                                  .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                                         )
+
+                           );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            TPSBarTask.instance().togglePlayer(player.getBukkitEntity());
+        }
+        return targets.size();
+    }
+}
diff --git a/src/main/java/com/kiocg/task/BossBarTask.java b/src/main/java/com/kiocg/task/BossBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d5b4181902210a4069bac1c43a718a4efd235cf
--- /dev/null
+++ b/src/main/java/com/kiocg/task/BossBarTask.java
@@ -0,0 +1,97 @@
+package com.kiocg.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.entity.Player;
+import org.bukkit.scheduler.BukkitRunnable;
+
+import java.util.*;
+
+public abstract class BossBarTask extends BukkitRunnable {
+    private final Map<UUID, BossBar> bossbars = new HashMap<>();
+    private boolean started;
+
+    abstract BossBar createBossBar();
+
+    abstract void updateBossBar(BossBar bossbar, Player player);
+
+    @Override
+    public void run() {
+        Iterator<Map.Entry<UUID, BossBar>> iter = bossbars.entrySet().iterator();
+        while (iter.hasNext()) {
+            Map.Entry<UUID, BossBar> entry = iter.next();
+            Player player = Bukkit.getPlayer(entry.getKey());
+            if (player == null) {
+                iter.remove();
+                continue;
+            }
+            updateBossBar(entry.getValue(), player);
+        }
+    }
+
+    @Override
+    public void cancel() {
+        super.cancel();
+        new HashSet<>(this.bossbars.keySet()).forEach(uuid -> {
+            Player player = Bukkit.getPlayer(uuid);
+            if (player != null) {
+                removePlayer(player);
+            }
+        });
+        this.bossbars.clear();
+    }
+
+    public boolean removePlayer(Player player) {
+        BossBar bossbar = this.bossbars.remove(player.getUniqueId());
+        if (bossbar != null) {
+            player.hideBossBar(bossbar);
+            return true;
+        }
+        return false;
+    }
+
+    public void addPlayer(Player player) {
+        removePlayer(player);
+        BossBar bossbar = createBossBar();
+        this.bossbars.put(player.getUniqueId(), bossbar);
+        this.updateBossBar(bossbar, player);
+        player.showBossBar(bossbar);
+    }
+
+    public boolean hasPlayer(UUID uuid) {
+        return this.bossbars.containsKey(uuid);
+    }
+
+    public boolean togglePlayer(Player player) {
+        if (removePlayer(player)) {
+            return false;
+        }
+        addPlayer(player);
+        return true;
+    }
+
+    public void start() {
+        stop();
+        this.runTaskTimerAsynchronously(new MinecraftInternalPlugin(), 1, 1);
+        started = true;
+    }
+
+    public void stop() {
+        if (started) {
+            cancel();
+        }
+    }
+
+    public static void startAll() {
+        TPSBarTask.instance().start();
+    }
+
+    public static void stopAll() {
+        TPSBarTask.instance().stop();
+    }
+
+    public static void removeFromAll(Player player) {
+        TPSBarTask.instance().removePlayer(player);
+    }
+}
diff --git a/src/main/java/com/kiocg/task/TPSBarTask.java b/src/main/java/com/kiocg/task/TPSBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..751c7b02564be5f79d293223612d21569bde10e0
--- /dev/null
+++ b/src/main/java/com/kiocg/task/TPSBarTask.java
@@ -0,0 +1,138 @@
+package com.kiocg.task;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+
+public class TPSBarTask extends BossBarTask {
+    private static TPSBarTask instance;
+    private double tps = 20.0D;
+    private double mspt = 0.0D;
+    private int tick = 0;
+
+    public static TPSBarTask instance() {
+        if (instance == null) {
+            instance = new TPSBarTask();
+        }
+        return instance;
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), 0.0F, GlobalConfiguration.get().kiocgConfig.commandTPSBarProgressColorGood, GlobalConfiguration.get().kiocgConfig.commandTPSBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        bossbar.progress(getBossBarProgress((float) mspt, 50.0F));
+        bossbar.color(getBossBarColor(FillMode.MSPT));
+        bossbar.name(MiniMessage.miniMessage().deserialize(GlobalConfiguration.get().kiocgConfig.commandTPSBarTitle,
+                                                           Placeholder.component("tps", getTPSColor()),
+                                                           Placeholder.component("mspt", getMSPTColor()),
+                                                           Placeholder.component("ping", getPingColor(player.getPing()))
+                                                          ));
+    }
+
+    @Override
+    public void run() {
+        if (++tick < GlobalConfiguration.get().kiocgConfig.commandTPSBarTickInterval) {
+            return;
+        }
+        tick = 0;
+
+        this.tps = Math.max(Math.min(Bukkit.getTPS()[0], 20.0D), 0.0D);
+        this.mspt = Bukkit.getAverageTickTime();
+
+        super.run();
+    }
+
+    private float getBossBarProgress(float dividend, float divisor) {
+        return Math.max(Math.min(dividend / divisor, 1.0F), 0.0F);
+    }
+
+    private BossBar.Color getBossBarColor(FillMode fillMode) {
+        if (isGood(fillMode)) {
+            return GlobalConfiguration.get().kiocgConfig.commandTPSBarProgressColorGood;
+        } else if (isMedium(fillMode)) {
+            return GlobalConfiguration.get().kiocgConfig.commandTPSBarProgressColorMedium;
+        } else {
+            return GlobalConfiguration.get().kiocgConfig.commandTPSBarProgressColorLow;
+        }
+    }
+
+    private boolean isGood(FillMode mode) {
+        return isGood(mode, 0);
+    }
+
+    private boolean isGood(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt <= 50;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 19;
+        } else if (mode == FillMode.PING) {
+            return ping < 100;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean isMedium(FillMode mode) {
+        return isMedium(mode, 0);
+    }
+
+    private boolean isMedium(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt <= 65;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 15;
+        } else if (mode == FillMode.PING) {
+            return ping < 200;
+        } else {
+            return false;
+        }
+    }
+
+    private Component getTPSColor() {
+        String color;
+        if (isGood(FillMode.TPS)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.TPS)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", tps)));
+    }
+
+    private Component getMSPTColor() {
+        String color;
+        if (isGood(FillMode.MSPT)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.MSPT)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", mspt)));
+    }
+
+    private Component getPingColor(int ping) {
+        String color;
+        if (isGood(FillMode.PING, ping)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.PING, ping)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = GlobalConfiguration.get().kiocgConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%s", ping)));
+    }
+
+    public enum FillMode {
+        TPS, MSPT, PING
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 593022f294774d3d4babf611f3f28e4e0c0d462f..1d0ffded5f67118406d64411f64e59ada46e1003 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -422,6 +422,16 @@ public class GlobalConfiguration extends ConfigurationPart {
         public boolean dontKillMyPet = true;
         public double petTeleportDistanceSqr = 256.0;
         public boolean petFollowKeepChunkLoaded = true;
+
+        public String commandTPSBarTitle = "<gray>TPS<yellow>:</yellow> <tps> MSPT<yellow>:</yellow> <mspt> Ping<yellow>:</yellow> <ping>ms";
+        public net.kyori.adventure.bossbar.BossBar.Overlay commandTPSBarProgressOverlay = net.kyori.adventure.bossbar.BossBar.Overlay.NOTCHED_20;
+        public net.kyori.adventure.bossbar.BossBar.Color commandTPSBarProgressColorGood = net.kyori.adventure.bossbar.BossBar.Color.GREEN;
+        public net.kyori.adventure.bossbar.BossBar.Color commandTPSBarProgressColorMedium = net.kyori.adventure.bossbar.BossBar.Color.YELLOW;
+        public net.kyori.adventure.bossbar.BossBar.Color commandTPSBarProgressColorLow = net.kyori.adventure.bossbar.BossBar.Color.RED;
+        public String commandTPSBarTextColorGood = "<gradient:#55ff55:#00aa00><text></gradient>";
+        public String commandTPSBarTextColorMedium = "<gradient:#ffff55:#ffaa00><text></gradient>";
+        public String commandTPSBarTextColorLow = "<gradient:#ff5555:#aa0000><text></gradient>";
+        public int commandTPSBarTickInterval = 20;
     }
     // KioCG end
 }
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 1d1e76de60e40224f5cb81893f9ee50fe987badb..d26aecbfbd1930e2c6938d049e45b700b3197230 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -250,6 +250,7 @@ public class Commands {
             StopCommand.register(this.dispatcher);
             TransferCommand.register(this.dispatcher);
             WhitelistCommand.register(this.dispatcher);
+            com.kiocg.command.TPSBarCommand.register(this.dispatcher); // KioCG
         }
 
         if (environment.includeIntegrated) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 330bee331335454a61cf8350a6654217c8124445..ed313384080ce4eb452880b40eef2a252e2e7dc9 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1140,6 +1140,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.safeShutdown(waitForShutdown, false);
     }
     public void safeShutdown(boolean waitForShutdown, boolean isRestarting) {
+        com.kiocg.task.BossBarTask.stopAll(); // KioCG
         this.isRestarting = isRestarting;
         this.hasLoggedStop = true; // Paper - Debugging
         if (isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index ff74e69ddc1423bec03937b61b3be04b2be4529d..48f3a21b79f00541f3c976f48b900d4f57d7443c 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -357,6 +357,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 DedicatedServer.LOGGER.info("JMX monitoring enabled");
             }
 
+            com.kiocg.task.BossBarTask.startAll(); // KioCG
             return true;
         }
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 1092d7acd21c8842375f20943cd3304186e34314..9e5202bb9ee1bc16282fba1b24d5f9ff4956954e 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -590,6 +590,7 @@ public abstract class PlayerList {
     }
     public net.kyori.adventure.text.Component remove(ServerPlayer entityplayer, net.kyori.adventure.text.Component leaveMessage) {
         // Paper end - Fix kick event leave message not being sent
+        com.kiocg.task.BossBarTask.removeFromAll(entityplayer.getBukkitEntity()); // KioCG
         ServerLevel worldserver = entityplayer.serverLevel();
 
         entityplayer.awardStat(Stats.LEAVE_GAME);
