From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joket_abc <15005771700@qq.com>
Date: Tue, 4 Jun 2024 13:28:44 +0800
Subject: [PATCH] Implement TPSBar


diff --git a/src/main/java/com/kiocg/command/TPSBarCommand.java b/src/main/java/com/kiocg/command/TPSBarCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff3fa06944b0c616a5a8ba9e5839f5cbc6085d7e
--- /dev/null
+++ b/src/main/java/com/kiocg/command/TPSBarCommand.java
@@ -0,0 +1,32 @@
+package com.kiocg.command;
+
+import com.kiocg.task.TPSBarTask;
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class TPSBarCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("tpsbar")
+                                    .requires(listener -> listener.hasPermission(2, "bukkit.command.tpsbar"))
+                                    .executes(context -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                                    .then(Commands.argument("targets", EntityArgument.players())
+                                                  .requires(listener -> listener.hasPermission(2, "bukkit.command.tpsbar.other"))
+                                                  .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                                         )
+
+                           );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            TPSBarTask.instance().togglePlayer(player.getBukkitEntity());
+        }
+        return targets.size();
+    }
+}
diff --git a/src/main/java/com/kiocg/task/BossBarTask.java b/src/main/java/com/kiocg/task/BossBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d1235b34e7cb69365d7b9a42b1d180434978b82
--- /dev/null
+++ b/src/main/java/com/kiocg/task/BossBarTask.java
@@ -0,0 +1,96 @@
+package com.kiocg.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.scheduler.BukkitRunnable;
+
+import java.util.*;
+
+public abstract class BossBarTask extends BukkitRunnable {
+    private final Map<UUID, BossBar> bossbars = new HashMap<>();
+    private boolean started;
+
+    abstract BossBar createBossBar();
+
+    abstract void updateBossBar(BossBar bossbar, Player player);
+
+    @Override
+    public void run() {
+        Iterator<Map.Entry<UUID, BossBar>> iter = bossbars.entrySet().iterator();
+        while (iter.hasNext()) {
+            Map.Entry<UUID, BossBar> entry = iter.next();
+            Player player = Bukkit.getPlayer(entry.getKey());
+            if (player == null) {
+                iter.remove();
+                continue;
+            }
+            updateBossBar(entry.getValue(), player);
+        }
+    }
+
+    @Override
+    public void cancel() {
+        super.cancel();
+        new HashSet<>(this.bossbars.keySet()).forEach(uuid -> {
+            Player player = Bukkit.getPlayer(uuid);
+            if (player != null) {
+                removePlayer(player);
+            }
+        });
+        this.bossbars.clear();
+    }
+
+    public boolean removePlayer(Player player) {
+        BossBar bossbar = this.bossbars.remove(player.getUniqueId());
+        if (bossbar != null) {
+            player.hideBossBar(bossbar);
+            return true;
+        }
+        return false;
+    }
+
+    public void addPlayer(Player player) {
+        removePlayer(player);
+        BossBar bossbar = createBossBar();
+        this.bossbars.put(player.getUniqueId(), bossbar);
+        this.updateBossBar(bossbar, player);
+        player.showBossBar(bossbar);
+    }
+
+    public boolean hasPlayer(UUID uuid) {
+        return this.bossbars.containsKey(uuid);
+    }
+
+    public boolean togglePlayer(Player player) {
+        if (removePlayer(player)) {
+            return false;
+        }
+        addPlayer(player);
+        return true;
+    }
+
+    public void start() {
+        stop();
+        this.runTaskTimerAsynchronously(new MinecraftInternalPlugin(), 1, 1);
+        started = true;
+    }
+
+    public void stop() {
+        if (started) {
+            cancel();
+        }
+    }
+
+    public static void startAll() {
+        TPSBarTask.instance().start();
+    }
+
+    public static void stopAll() {
+        TPSBarTask.instance().stop();
+    }
+
+    public static void removeFromAll(Player player) {
+        TPSBarTask.instance().removePlayer(player);
+    }
+}
diff --git a/src/main/java/com/kiocg/task/MinecraftInternalPlugin.java b/src/main/java/com/kiocg/task/MinecraftInternalPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..97be10af4909e5054971192be9a3ead02cc63894
--- /dev/null
+++ b/src/main/java/com/kiocg/task/MinecraftInternalPlugin.java
@@ -0,0 +1,153 @@
+package com.kiocg.task;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.BiomeProvider;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginBase;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+import java.util.logging.Logger;
+
+public class MinecraftInternalPlugin extends PluginBase {
+    private boolean enabled = true;
+
+    private final String pluginName;
+    private PluginDescriptionFile pdf;
+
+    public MinecraftInternalPlugin() {
+        this.pluginName = "Minecraft";
+        pdf = new PluginDescriptionFile(pluginName, "1.0", "nms");
+    }
+
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    @Override
+    public @NotNull File getDataFolder() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull PluginDescriptionFile getDescription() {
+        return pdf;
+    }
+
+    @NotNull
+    @Override
+    public PluginMeta getPluginMeta() {
+        return pdf;
+    }
+
+    @Override
+    public @NotNull FileConfiguration getConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @Nullable InputStream getResource(@NotNull String filename) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveResource(@NotNull String resourcePath, boolean replace) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void reloadConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull PluginLoader getPluginLoader() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull Server getServer() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    @Override
+    public void onDisable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onLoad() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onEnable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isNaggable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @Nullable ChunkGenerator getDefaultWorldGenerator(@NotNull String worldName, @Nullable String id) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @Nullable BiomeProvider getDefaultBiomeProvider(@NotNull String worldName, @Nullable String id) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull Logger getLogger() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull LifecycleEventManager<Plugin> getLifecycleManager() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+}
diff --git a/src/main/java/com/kiocg/task/TPSBarTask.java b/src/main/java/com/kiocg/task/TPSBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c44d94ba77a24023e77ef4c778b181736ff5f98
--- /dev/null
+++ b/src/main/java/com/kiocg/task/TPSBarTask.java
@@ -0,0 +1,138 @@
+package com.kiocg.task;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+
+public class TPSBarTask extends BossBarTask {
+    private static TPSBarTask instance;
+    private double tps = 20.0D;
+    private double mspt = 0.0D;
+    private int tick = 0;
+
+    public static TPSBarTask instance() {
+        if (instance == null) {
+            instance = new TPSBarTask();
+        }
+        return instance;
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), 0.0F, GlobalConfiguration.get().kiocgConfig.commandTpsBarProgressColorGood, GlobalConfiguration.get().kiocgConfig.commandTpsBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        bossbar.progress(getBossBarProgress((float) mspt, 50.0F));
+        bossbar.color(getBossBarColor(FillMode.MSPT));
+        bossbar.name(MiniMessage.miniMessage().deserialize(GlobalConfiguration.get().kiocgConfig.commandTpsBarTitle,
+                                                           Placeholder.component("tps", getTPSColor()),
+                                                           Placeholder.component("mspt", getMSPTColor()),
+                                                           Placeholder.component("ping", getPingColor(player.getPing()))
+                                                          ));
+    }
+
+    @Override
+    public void run() {
+        if (++tick < GlobalConfiguration.get().kiocgConfig.commandTpsBarTickInterval) {
+            return;
+        }
+        tick = 0;
+
+        this.tps = Math.max(Math.min(Bukkit.getTPS()[0], 20.0D), 0.0D);
+        this.mspt = Bukkit.getAverageTickTime();
+
+        super.run();
+    }
+
+    private float getBossBarProgress(float dividend, float divisor) {
+        return Math.max(Math.min(dividend / divisor, 1.0F), 0.0F);
+    }
+
+    private BossBar.Color getBossBarColor(FillMode fillMode) {
+        if (isGood(fillMode)) {
+            return GlobalConfiguration.get().kiocgConfig.commandTpsBarProgressColorGood;
+        } else if (isMedium(fillMode)) {
+            return GlobalConfiguration.get().kiocgConfig.commandTpsBarProgressColorMedium;
+        } else {
+            return GlobalConfiguration.get().kiocgConfig.commandTpsBarProgressColorLow;
+        }
+    }
+
+    private boolean isGood(FillMode mode) {
+        return isGood(mode, 0);
+    }
+
+    private boolean isGood(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt <= 50;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 19;
+        } else if (mode == FillMode.PING) {
+            return ping < 100;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean isMedium(FillMode mode) {
+        return isMedium(mode, 0);
+    }
+
+    private boolean isMedium(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt <= 65;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 15;
+        } else if (mode == FillMode.PING) {
+            return ping < 200;
+        } else {
+            return false;
+        }
+    }
+
+    private Component getTPSColor() {
+        String color;
+        if (isGood(FillMode.TPS)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorGood;
+        } else if (isMedium(FillMode.TPS)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorMedium;
+        } else {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", tps)));
+    }
+
+    private Component getMSPTColor() {
+        String color;
+        if (isGood(FillMode.MSPT)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorGood;
+        } else if (isMedium(FillMode.MSPT)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorMedium;
+        } else {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", mspt)));
+    }
+
+    private Component getPingColor(int ping) {
+        String color;
+        if (isGood(FillMode.PING, ping)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorGood;
+        } else if (isMedium(FillMode.PING, ping)) {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorMedium;
+        } else {
+            color = GlobalConfiguration.get().kiocgConfig.commandTpsBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%s", ping)));
+    }
+
+    public enum FillMode {
+        TPS, MSPT, PING
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 0495547f5dcb870962d2d9ec947adfda13d1dc2f..525c8d31ec3097bc975252c6ff1e07ade12cb74e 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -429,6 +429,16 @@ public class GlobalConfiguration extends ConfigurationPart {
         public boolean dontKillMyPet = true;
         public double petTeleportDistanceSqr = 256.0;
         public boolean petFollowKeepChunkLoaded = true;
+
+        public String commandTpsBarTitle = "<gray>TPS<yellow>:</yellow> <tps> MSPT<yellow>:</yellow> <mspt> Ping<yellow>:</yellow> <ping>ms";
+        public net.kyori.adventure.bossbar.BossBar.Overlay commandTpsBarProgressOverlay = net.kyori.adventure.bossbar.BossBar.Overlay.NOTCHED_20;
+        public net.kyori.adventure.bossbar.BossBar.Color commandTpsBarProgressColorGood = net.kyori.adventure.bossbar.BossBar.Color.GREEN;
+        public net.kyori.adventure.bossbar.BossBar.Color commandTpsBarProgressColorMedium = net.kyori.adventure.bossbar.BossBar.Color.YELLOW;
+        public net.kyori.adventure.bossbar.BossBar.Color commandTpsBarProgressColorLow = net.kyori.adventure.bossbar.BossBar.Color.RED;
+        public String commandTpsBarTextColorGood = "<gradient:#55ff55:#00aa00><text></gradient>";
+        public String commandTpsBarTextColorMedium = "<gradient:#ffff55:#ffaa00><text></gradient>";
+        public String commandTpsBarTextColorLow = "<gradient:#ff5555:#aa0000><text></gradient>";
+        public int commandTpsBarTickInterval = 20;
     }
     // KioCG end
 }
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 1d1e76de60e40224f5cb81893f9ee50fe987badb..d26aecbfbd1930e2c6938d049e45b700b3197230 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -250,6 +250,7 @@ public class Commands {
             StopCommand.register(this.dispatcher);
             TransferCommand.register(this.dispatcher);
             WhitelistCommand.register(this.dispatcher);
+            com.kiocg.command.TPSBarCommand.register(this.dispatcher); // KioCG
         }
 
         if (environment.includeIntegrated) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 9325d6f95165a7cee00d7de736af723681cc16b4..8206de9c96c19ce3c32293beebdd75d778cd4974 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1135,6 +1135,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.safeShutdown(waitForShutdown, false);
     }
     public void safeShutdown(boolean waitForShutdown, boolean isRestarting) {
+        com.kiocg.task.BossBarTask.stopAll(); // KioCG
         this.isRestarting = isRestarting;
         this.hasLoggedStop = true; // Paper - Debugging
         if (isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index c5592d288325e35f4c7150a8b2696954eafbf5a6..fec556836eb03e28d3e8abc0aca49ea8957856b0 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -359,6 +359,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 DedicatedServer.LOGGER.info("JMX monitoring enabled");
             }
 
+            com.kiocg.task.BossBarTask.startAll(); // KioCG
             return true;
         }
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 511da4fcb807b25df763e760f38d3b246476d78a..6df8f121b2c01db395e00092c6cea3160ac7b0f1 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -591,6 +591,7 @@ public abstract class PlayerList {
     }
     public net.kyori.adventure.text.Component remove(ServerPlayer entityplayer, net.kyori.adventure.text.Component leaveMessage) {
         // Paper end - Fix kick event leave message not being sent
+        com.kiocg.task.BossBarTask.removeFromAll(entityplayer.getBukkitEntity()); // KioCG
         ServerLevel worldserver = entityplayer.serverLevel();
 
         entityplayer.awardStat(Stats.LEAVE_GAME);
